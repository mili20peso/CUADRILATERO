----QUIT----2020-06-29T10:47:39.890105+02:00 Pharo7.0.5-0-32bit-fd8c156.image priorSource: 0!----QUIT----2020-06-29T10:47:54.496471+02:00 Pharo7.0.5-0-32bit-fd8c156.image priorSource: 0!Object subclass: #CuadrilaterosGAME	instanceVariableNames: ''	classVariableNames: ''	package: ''!Object subclass: #CuadrilaterosDice    instanceVariableNames: 'random'    classVariableNames: ''	package: 'Cuadrilateros-Juego'!Object subclass: #CuadrilaterosDice	instanceVariableNames: 'random'	classVariableNames: ''	package: 'Cuadrilateros-Juego'	"Clase dados"!!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 10:52'!initialize    super initialize.    "Creamos una única instancia de Random para reutilizar la semilla"    random := Random new.! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:03'!rollX    "Retorna un número para las columnas (X) de 1 a 6"    ^ random nextInt: 6! !Object subclass: #CuadrilaterosDice	instanceVariableNames: 'random x y'	classVariableNames: ''	package: 'Cuadrilateros-Juego'!!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:09'!roll    "Retorna un número para las columnas (X) de 1 a 6"    ^ random nextInt: 6! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:12'!getX    "Retorna un número para las columnas (X) de 1 a 6"    x:= self roll ! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:14'!getY    "Retorna un número para las filas (Y) de 1 a 6"    y:= self roll ! !CuadrilaterosDice removeSelector: #rollX!!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:49'!rollWithConfig: modifiers	    "Genera una tirada aplicando las reglas del diccionario de configuración.     Claves esperadas: '+1', '-1', '<3', '>3'"        | result conditionMet |	 modifiers isEmpty ifTrue: [ ^ random nextInt: 6 ]. "interrumpe si no hay modifiers"        "BASE"    result := random nextInt: 6.        "REROLL"        "Si tiene <3 (Debe ser menor a 3). Mientras sea >= 3, tira de nuevo."    (modifiers includesKey: '<3') ifTrue: [         [ result >= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "Si tiene >3 (Debe ser mayor a 3). Mientras sea <= 3, tira de nuevo."    (modifiers includesKey: '>3') ifTrue: [         [ result <= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "MODIFICADORES +-1"        "Caso: +1"    (modifiers includesKey: '+1') ifTrue: [         result := result + 1     ].    "Caso: -1 (Con restricción de mínimo 1)"    (modifiers includesKey: '-1') ifTrue: [         result := result - 1.    ].    "Aseguramos que el resultado nunca sea menor a 1 tras la resta"    ^ result max: 1! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:49' prior: 33556170!rollWithConfig: modifiers	    "Genera una tirada aplicando las reglas del diccionario de configuración.     Claves esperadas: '+1', '-1', '<3', '>3'"        | result |	 modifiers isEmpty ifTrue: [ ^ random nextInt: 6 ]. "interrumpe si no hay modifiers"        "BASE"    result := random nextInt: 6.        "REROLL"        "Si tiene <3 (Debe ser menor a 3). Mientras sea >= 3, tira de nuevo."    (modifiers includesKey: '<3') ifTrue: [         [ result >= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "Si tiene >3 (Debe ser mayor a 3). Mientras sea <= 3, tira de nuevo."    (modifiers includesKey: '>3') ifTrue: [         [ result <= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "MODIFICADORES +-1"        "Caso: +1"    (modifiers includesKey: '+1') ifTrue: [         result := result + 1     ].    "Caso: -1 (Con restricción de mínimo 1)"    (modifiers includesKey: '-1') ifTrue: [         result := result - 1.    ].    "Aseguramos que el resultado nunca sea menor a 1 tras la resta"    ^ result max: 1! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:50'!roll: modifiers	    "Genera una tirada aplicando las reglas del diccionario de configuración.     Claves esperadas: '+1', '-1', '<3', '>3'"        | result |	 modifiers isEmpty ifTrue: [ ^ random nextInt: 6 ]. "interrumpe si no hay modifiers"        "BASE"    result := random nextInt: 6.        "REROLL"        "Si tiene <3 (Debe ser menor a 3). Mientras sea >= 3, tira de nuevo."    (modifiers includesKey: '<3') ifTrue: [         [ result >= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "Si tiene >3 (Debe ser mayor a 3). Mientras sea <= 3, tira de nuevo."    (modifiers includesKey: '>3') ifTrue: [         [ result <= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "MODIFICADORES +-1"        "Caso: +1"    (modifiers includesKey: '+1') ifTrue: [         result := result + 1     ].    "Caso: -1 (Con restricción de mínimo 1)"    (modifiers includesKey: '-1') ifTrue: [         result := result - 1.    ].    "Aseguramos que el resultado nunca sea menor a 1 tras la resta"    ^ result max: 1! !CuadrilaterosDice removeSelector: #rollWithConfig:!!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:57'!rollMod: modifiers	    "Genera una tirada aplicando las reglas del diccionario de configuración.     Claves esperadas: '+1', '-1', '<3', '>3'"        | result |	 (modifiers isNil or: [ modifiers isEmpty ]) ifTrue: [ ^ random nextInt: 6 ]. 	"interrumpe si no hay modifiers"        "BASE"    result := random nextInt: 6.        "REROLL"        "Si tiene <3 (Debe ser menor a 3). Mientras sea >= 3, tira de nuevo."    (modifiers includesKey: '<3') ifTrue: [         [ result >= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "Si tiene >3 (Debe ser mayor a 3). Mientras sea <= 3, tira de nuevo."    (modifiers includesKey: '>3') ifTrue: [         [ result <= 3 ] whileTrue: [ result := random nextInt: 6 ]    ].    "MODIFICADORES +-1"        "Caso: +1"    (modifiers includesKey: '+1') ifTrue: [         result := result + 1     ].    "Caso: -1 (Con restricción de mínimo 1)"    (modifiers includesKey: '-1') ifTrue: [         result := result - 1.    ].    "Aseguramos que el resultado nunca sea menor a 1 tras la resta"    ^ result max: 1! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:58' prior: 33558511!roll: modifiers    "Recibe el diccionario, calcula los nuevos valores y actualiza el estado interno"        x := self rollWithConfig: modifiers.    y := self rollWithConfig: modifiers.! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:58' prior: 33560903!roll: modifiers    "Recibe el diccionario, calcula los nuevos valores y actualiza el estado interno"        x := self rollMod: modifiers.    y := self rollMod: modifiers.! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:59'!x	^x! !CuadrilaterosDice removeSelector: #getY!CuadrilaterosDice removeSelector: #getX!!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 11:59'!y	^y! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 12:01' prior: 33555615!roll    "Retorna un número para las columnas (X) de 1 a 6"    x:= random nextInt: 6.	 y:= random nextInt:6.! !!CuadrilaterosDice methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/20/2025 12:12' prior: 33561755!roll    "Retorna un número para las columnas (X) de 1 a 6"    x:= random nextInt: 6.	 y:= random nextInt:6. ! !Object subclass: #CuadrilaterosPowerUp    instanceVariableNames: ''    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!ManifestCuadrilaterosJuego commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestCuadrilaterosJuego class methodsFor: 'code-critics' stamp: 'MarcoM 11/21/2025 10:53'!ruleRBNoClassCommentRuleV1FalsePositive	^ #()! !!ManifestCuadrilaterosJuego class methodsFor: 'code-critics' stamp: 'MarcoM 11/21/2025 10:53' prior: 33562518!ruleRBNoClassCommentRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#CuadrilaterosPowerUp)) #'2025-11-21T10:53:01.86801-03:00') )! !!CuadrilaterosPowerUp methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 10:53'!activateOn: aPlayer game: aGame    self subclassResponsibility! !CuadrilaterosPowerUp subclass: #PowerUpPlusOne    instanceVariableNames: ''    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!PowerUpPlusOne methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 10:57'!activateOn: aPlayer game: aGame    "Le dice al jugador que agregue el efecto de sumar 1 a su lista de efectos activos"    aPlayer addEffect: #plusOne.! !CuadrilaterosPowerUp subclass: #PowerUpMinusOne    instanceVariableNames: ''    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!PowerUpMinusOne methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 11:21'!activateOn: aPlayer game: aGame    aPlayer addEffect: #minusOne.! !CuadrilaterosPowerUp subclass: #PowerUpLowRoll    instanceVariableNames: ''    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!PowerUpLowRoll methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 11:24'!activateOn: aPlayer game: aGame    aPlayer addEffect: #forceLowRoll.! !CuadrilaterosPowerUp subclass: #PowerUpHighRoll    instanceVariableNames: ''    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!PowerUpHighRoll methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 11:29'!activateOn: aPlayer game: aGame    aPlayer addEffect: #forceHighRoll.! !!CuadrilaterosDice methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 11:30' prior: 33555087!initialize    super initialize.    "Creamos una única instancia de Random para no generar seeds todo el tiempo"    random := Random new.! !!PowerUpPlusOne methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 11:30' prior: 33563193!activateOn: aPlayer game: aGame    aPlayer addEffect: #plusOne.! !----SNAPSHOT----2025-11-21T12:13:26.48101-03:00 Juego CUADRILATEROS.1.image priorSource: 95!----SNAPSHOT----2025-11-21T14:56:51.44601-03:00 Juego CUADRILATEROS.1.image priorSource: 10212!!PowerUpMinusOne commentStamp: 'MarcoM 11/21/2025 16:40' prior: 0!Potenciador dado menos 1!!PowerUpPlusOne commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Dados mas 1!!PowerUpLowRoll commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Potenciados dados mas bajos!!PowerUpHighRoll commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Potenciador dados mas altos!!CuadrilaterosPowerUp commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Clase abstracta de potenciadores!!CuadrilaterosGAME commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Classe contenedora juego!!CuadrilaterosDice commentStamp: 'MarcoM 11/21/2025 16:41' prior: 0!Clase dados!Object subclass: #CuadrilaterosPlayer    instanceVariableNames: 'id lives areaCovered turnsPlayed activeEffects'    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!CuadrilaterosPlayer commentStamp: 'MarcoM 11/21/2025 16:42' prior: 0!Clase jugador!!CuadrilaterosPlayer methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 16:45'!initialize    "Inicializa las variables con los valores por defecto del juego"    super initialize.    lives := 3.              "Comienzan con 3 vidas"    areaCovered := 0.        "0 superficie cubierta al inicio"    turnsPlayed := 0.        "0 turnos jugados"    activeEffects := OrderedCollection new. "Lista vacía para guardar potenciadores"! !!CuadrilaterosPlayer methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 16:46'!id    "Devuelve el identificador del jugador (ej: 'Jugador 1' o #Blue)"    ^ id! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:46'!id: anObject    "Establece el identificador del jugador"    id := anObject! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:47'!lives    "Devuelve la cantidad actual de vidas"    ^ lives! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:47'!areaCovered    "Devuelve el área total cubierta por el jugador"    ^ areaCovered! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:47'!turnsPlayed    "Devuelve la cantidad de turnos que el jugador ha sobrevivido"    ^ turnsPlayed! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:47'!loseLife    "Resta una vida al jugador. Se invoca cuando no puede colocar figura."    lives := lives - 1.! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:48'!isAlive    "Devuelve true si el jugador tiene más de 0 vidas, false si perdió."    ^ lives > 0! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:48'!addArea: anInteger    "Suma una cantidad de unidades cuadradas al total del jugador.     anInteger: es el resultado de base * altura de la figura colocada."    areaCovered := areaCovered + anInteger.! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:51'!recordTurn    "Incrementa el contador de turnos jugados.      Se debe llamar al inicio de cada turno de este jugador."    turnsPlayed := turnsPlayed + 1.! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:52'!addPowerUp: aPowerUp    "Agrega un potenciador a la lista de efectos activos.     aPowerUp: es una instancia de una subclase de PowerUp."    activeEffects add: aPowerUp.! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:53'!clearTurnEffects    "Borra todos los efectos acumulados.      Se debe llamar al FINAL del turno para que los efectos como      +1 dado o Sobrescribir no se queden para siempre."    activeEffects removeAll.! !!CuadrilaterosPlayer methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 16:55'!activeEffects    "Devuelve la colección de efectos activos actualmente"    ^ activeEffects! !!CuadrilaterosPlayer methodsFor: 'accessing' stamp: 'MarcoM 11/21/2025 16:55'!hasPowerUp: aPowerUpClass    "Verifica si el jugador tiene un tipo específico de potenciador activo.     Útil para que el Tablero pregunte si puede sobrescribir.     Ejemplo: player hasPowerUp: OverwritePowerUp"        ^ activeEffects anySatisfy: [ :each | each isKindOf: aPowerUpClass ]! !----SNAPSHOT----2025-11-21T16:58:43.50401-03:00 Juego CUADRILATEROS.1.image priorSource: 10306!Object subclass: #CuadrilaterosBoard    instanceVariableNames: 'grid rows columns'    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!CuadrilaterosBoard methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 17:05'!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        super initialize.    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Matrix new: rows tabulate: [ :r :c | nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:05' prior: 33569344!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        self initialize.    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Matrix new: rows tabulate: [ :r :c | nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:06' prior: 33569771!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        self initialize.    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Matrix new: rows tabulate: [ :r :c | nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:07' prior: 33570197!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        self initialize. "me lo cambiaron por self, antes era super, por si falla"    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Matrix new: rows tabulate: [ :r :c | nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:07'!isValidCoordinate: aPoint    "Verifica que el punto (x@y) esté dentro de los límites del tablero"    ^ (aPoint x between: 1 and: columns) and: [ aPoint y between: 1 and: rows ]! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:08' prior: 33570623!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        self initialize. "me lo cambiaron por self, antes era super, por si falla"    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Array2D new: rows tabulate: [ :r :c | nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:08' prior: 33571374!initializeSize: anInteger    "Crea un tablero cuadrado de anInteger x anInteger.     anInteger puede ser 16, 20 o 24 según la consigna."        self initialize. "me lo cambiaron por self, antes era super, por si falla"    rows := anInteger.    columns := anInteger.        "Creamos una Matriz llena de nils (vacía)"    grid := Array2D new: rows tabulate: [ :r :c | nil ]. "antes d ecia matrix en vez de array2d, por si falla"! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:09'!contentAt: aPoint    "Devuelve lo que hay en esa celda: nil, un ID de jugador o un PowerUp"    (self isValidCoordinate: aPoint)         ifTrue: [ ^ grid at: aPoint y at: aPoint x ]         ifFalse: [ ^ nil ].! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:20'!checkAdjacencyFor: originPoint width: w height: h player: aPlayer    "Revisa si alguna celda del perímetro de la nueva figura toca una celda propia.     Optimizado para recorrer solo los bordes y retornar apenas encuentre coincidencia."        | startX startY endX endY checkCellBlock|        startX := originPoint x.    startY := originPoint y.    endX := startX + w - 1.    endY := startY + h - 1.    "Definimos un bloque para chequear los 4 vecinos de un punto dado"    checkCellBlock := [ :currentPoint |        | neighbors |        neighbors := { currentPoint + (0@1) . currentPoint - (0@1) . currentPoint + (1@0) . currentPoint - (1@0) }.                neighbors do: [ :n |            "Usamos and: para short-circuit evaluation (si no es valida, no evalua el contenido)"            ((self isValidCoordinate: n) and: [ (self contentAt: n) = aPlayer id ])                 ifTrue: [ ^ true ]. "Retorna true y sale del METODO completo inmediatamente"        ].    ].    "1. Recorrer Fila Superior e Inferior"    startX to: endX do: [ :x |        checkCellBlock value: (x @ startY).           "Borde Superior"        (h > 1) ifTrue: [ checkCellBlock value: (x @ endY) ]. "Borde Inferior (si existe)"    ].    "2. Recorrer Columna Izquierda y Derecha (sin las esquinas ya chequeadas)"    startY + 1 to: endY - 1 do: [ :y |        checkCellBlock value: (startX @ y).           "Borde Izquierdo"        (w > 1) ifTrue: [ checkCellBlock value: (endX @ y) ]. "Borde Derecho (si existe)"    ].    ^ false "Si recorrió todo el perímetro sin salir antes, no hay adyacencia"! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:22' prior: 33572681!checkAdjacencyFor: originPoint width: w height: h player: aPlayer    "Revisa si alguna celda del perímetro de la nueva figura toca una celda propia.     originPoint es x@y."        | startX startY endX endY neighbors foundAdjacency |    startX := originPoint x.    startY := originPoint y.    endX := startX + w - 1.    endY := startY + h - 1.    foundAdjacency := false.    "Iteramos sobre cada celda de la nueva figura propuesta"    startX to: endX do: [ :x |        startY to: endY do: [ :y |            "Para cada celda, miramos sus 4 vecinos (Arriba, Abajo, Izq, Der)"            neighbors := { (x@y) + (0@1) . (x@y) - (0@1) . (x@y) + (1@0) . (x@y) - (1@0) }.                        neighbors do: [ :n |                (self isValidCoordinate: n) ifTrue: [                    "Si el vecino tiene el ID del jugador, es válido"                    ((self contentAt: n) = aPlayer id) ifTrue: [ foundAdjacency := true ].                ].            ].        ].    ].    ^ foundAdjacency! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:23'!canPlaceShape: originPoint width: w height: h player: aPlayer    "Valida si se puede colocar la figura según reglas: Límites, Superposición y Adyacencia"        | startX startY endX endY cellContent canOverwrite |    startX := originPoint x.    startY := originPoint y.    endX := startX + w - 1.    endY := startY + h - 1.    "1. Validar que la figura entera entre en el tablero (Límites)"    ((self isValidCoordinate: originPoint) and: [ self isValidCoordinate: endX@endY ])         ifFalse: [ ^ false ].    "2. Validar Superposición"    "Preguntamos al jugador si tiene el PowerUp de sobrescribir"    canOverwrite := aPlayer hasPowerUp: CuadrilaterosPowerUpOverwrite.     startX to: endX do: [ :x |        startY to: endY do: [ :y |            cellContent := grid at: y at: x.                        "Si la celda no está vacía y NO es un PowerUp..."            (cellContent notNil and: [ (cellContent isKindOf: CuadrilaterosPowerUp) not ]) ifTrue: [                "Si no puedo sobrescribir, es un movimiento ilegal"                canOverwrite ifFalse: [ ^ false ].            ].        ].    ].    "3. Validar Adyacencia (Obligatorio tocar territorio propio)"    ^ self checkAdjacencyFor: originPoint width: w height: h player: aPlayer.! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:25'!placeShape: originPoint width: w height: h player: aPlayer    "Dibuja la figura en el tablero, consume PowerUps y actualiza el área del jugador"        | startX startY endX endY cellContent |    startX := originPoint x.    startY := originPoint y.    endX := startX + w - 1.    endY := startY + h - 1.        startX to: endX do: [ :x |        startY to: endY do: [ :y |            cellContent := grid at: y at: x.                        "Si pisamos un PowerUp, se lo damos al jugador"            (cellContent isKindOf: CuadrilaterosPowerUp) ifTrue: [                aPlayer addPowerUp: cellContent.            ].                        "Marcamos la celda con el ID del jugador"            grid at: y at: x put: aPlayer id.        ].    ].    "Sumamos el área al jugador (w * h)"    aPlayer addArea: (w * h).! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:28'!spawnRandomPowerUp    "Intenta colocar un PowerUp aleatorio en una celda vacía"    | r c attempts maxAttempts |        "Usamos random para elegir fila y columna"    attempts := 0.    maxAttempts := 10. "Para evitar bucles infinitos si el tablero está lleno"        [ attempts < maxAttempts ] whileTrue: [        r := (1 to: rows) atRandom.        c := (1 to: columns) atRandom.                (grid at: r at: c) isNil ifTrue: [            "Si está vacío, ponemos un PowerUp random"            grid at: r at: c put: (CuadrilaterosPowerUp randomSubclass new).            ^ self "Salimos del método"        ].        attempts := attempts + 1.    ].! !!ManifestCuadrilaterosJuego class methodsFor: 'code-critics' stamp: 'MarcoM 11/21/2025 17:29'!ruleRBWhileTrueRuleV1FalsePositive	^ #()! !!ManifestCuadrilaterosJuego class methodsFor: 'code-critics' stamp: 'MarcoM 11/21/2025 17:29' prior: 33578543!ruleRBWhileTrueRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CuadrilaterosBoard #spawnRandomPowerUp #false)) #'2025-11-21T17:29:34.43801-03:00') )! !!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:34'!placeRandomBlockFor: aPlayer    "Busca una celda vacía de forma aleatoria y se la asigna al jugador.     Si el azar falla muchas veces, busca linealmente."        | x y attempts maxAttempts |        maxAttempts := 50. "Intentamos 50 veces encontrar un lugar al azar"    attempts := 0.        "--- INTENTO ALEATORIO ---"    [ attempts < maxAttempts ] whileTrue: [        x := (1 to: columns) atRandom.        y := (1 to: rows) atRandom.                "Si la celda es nil (vacía), la ocupamos y terminamos"        (grid at: y at: x) isNil ifTrue: [            grid at: y at: x put: aPlayer id.            aPlayer addArea: 1.            ^ self "Salimos del método inmediatamente"        ].                attempts := attempts + 1.    ].    "--- INTENTO LINEAL (FALLBACK) ---"    "Si el tablero está muy lleno, el azar puede fallar.      Para garantizar que el PowerUp funcione, recorremos todo si el azar falló."        1 to: rows do: [ :r |        1 to: columns do: [ :c |            (grid at: r at: c) isNil ifTrue: [                grid at: r at: c put: aPlayer id.                aPlayer addArea: 1.                ^ self "Encontrado por búsqueda lineal"            ].        ].    ].        "Si llega aquí, el tablero está 100% lleno y no se hace nada."! !!ManifestCuadrilaterosJuego class methodsFor: 'code-critics' stamp: 'MarcoM 11/21/2025 17:34' prior: 33578699!ruleRBWhileTrueRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CuadrilaterosBoard #spawnRandomPowerUp #false)) #'2025-11-21T17:29:34.43801-03:00') #(#(#RGMethodDefinition #(#CuadrilaterosBoard #placeRandomBlockFor: #false)) #'2025-11-21T17:34:55.01501-03:00') )! !!CuadrilaterosPowerUp methodsFor: 'as yet unclassified' stamp: 'MarcoM 11/21/2025 17:36'!randomSubclass    "Devuelve una de las subclases concretas al azar.     Usa 'subclasses' que devuelve una colección con los hijos de esta clase."        ^ self subclasses atRandom! !----SNAPSHOT----2025-11-21T17:38:49.14601-03:00 Juego CUADRILATEROS.1.image priorSource: 14581!Object subclass: #CuadrilaterosGAMEinstanceVariableNames: 'board players dice currentPlayerIndex isGameOver'    classVariableNames: ''	package: 'Cuadrilateros-Juego'!!CuadrilaterosBoard methodsFor: 'initialization' stamp: 'MarcoM 11/21/2025 17:47' prior: 33578938!placeRandomBlockFor: aPlayer    "Busca una celda vacía de forma aleatoria y se la asigna al jugador.     Si el azar falla muchas veces, busca linealmente."        | x y attempts maxAttempts |        maxAttempts := 50. "Intentamos 50 veces encontrar un lugar al azar"    attempts := 0.        "--- INTENTO ALEATORIO ---"    [ attempts < maxAttempts ] whileTrue: [        x := (1 to: columns) atRandom.        y := (1 to: rows) atRandom.                "Si la celda es nil (vacía), la ocupamos y terminamos"        (grid at: y at: x) isNil ifTrue: [            grid at: y at: x put: aPlayer id.            aPlayer addArea: 1.            ^ self "Salimos del método inmediatamente"        ].                attempts := attempts + 1.    ].    "--- INTENTO LINEAL ---"    "Si el azar falla, para garantizar que el PowerUp funcione, recorremos todo linealmente."        1 to: rows do: [ :r |        1 to: columns do: [ :c |            (grid at: r at: c) isNil ifTrue: [                grid at: r at: c put: aPlayer id.                aPlayer addArea: 1.                ^ self "Encontrado por búsqueda lineal"            ].        ].    ].        "Si llega aquí, el tablero está 100% lleno y no se hace nada."! !!CuadrilaterosBoard commentStamp: 'MarcoM 11/21/2025 17:48' prior: 0!Tablero de juego!!CuadrilaterosGAME commentStamp: 'MarcoM 11/21/2025 17:48' prior: 33565374!Classe contenedora de juego!----SNAPSHOT----2025-11-21T17:51:20.45401-03:00 Juego CUADRILATEROS.1.image priorSource: 26469!----SNAPSHOT----2025-11-21T17:53:07.91601-03:00 Juego CUADRILATEROS.1.image priorSource: 28277!